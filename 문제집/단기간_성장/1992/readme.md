## 문제 소개

[곱셈](https://www.acmicpc.net/problem/1629)

## 풀이

오랜 시간을 들였지만 풀지 못하여 정답을 보고 풀이하였습니다.

- [참고한 블로그](https://rujang.tistory.com/entry/%EB%B0%B1%EC%A4%80-1629%EB%B2%88-%EA%B3%B1%EC%85%88-CC)

- 몰랐던 것들
  - 모듈러 연산의 곱셈 성질
    - (A * B) % C = (A % C * B % C) % C
  - 모듈러는 곱셈, 나눗셈과 우선도가 같다.
  - O(n)을 O(log2 n)으로 연산량을 줄이기 위해서 2로 나누는 방식.
    - 작은 연산으로 줄여서 해결하는 분할 정복.
  - 9경 이상의 연산은 BigInt를 사용해야 정확도가 보장된다.

곱셈 문제는 모듈러 연산을 적용하는 값에 대해 가능한 작은 연산으로 줄인 뒤 점진적으로 해결하는 분할 정복 방식을 사용한다.

또한 n이 최대 21억이므로 O(n)으로도 순회량이 많음. 시간 복잡도를 줄이기 위해서 O(log n)으로 접근해야함. 이를 위해 지수를 2로 나눠 홀수/짝수로 분기하는 접근이 필요함.

예를 들어 다음과 같다.
1. B가 홀수
  - A^(B) % C = A^(B/2 + B/2 + 1) % C
  - 이후 모듈러 성질에 따라 전개.
2. B가 짝수
  - A^(B) % C = A^(B/2 + B/2) % C
  - 이후 모듈러 성질에 따라 전개.

각각 식을 정리하면 B(=exponent)가 1일 때 A % C의 결과를 리턴하는 재귀함수를 만들 수 있음.

해당 함수는 재귀 호출이 반복될수록, 작은 연산으로 줄어듦. 작은 연산으로 큰 연산 결과를 얻을 수 있음.

++ 추가
A=2147483646
B=2147483646
C=2147483647

의 입력이었을 때 아무리 해도 정답이 나오지 않아서 디깅해봤더니 BigInt를 쓰지 않아 발생한 문제였다. 한번이라도 21억 * 21억 연산이 발생하면 number가 보장하는 정확도인 9경을 넘음. 꼭 BigInt를 쓰자.


## 실패한 풀이 기록

- 12
- 24
- 36
- 48
- 60
- 72
- 84
- 96
- 108
- 120 (12 + 8)
- 132 (24 + 8)
- 144 (36 + 8)
- 156 (48 + 8)

끝자리가 2,4,6,8,0 을 반복함.
끝 앞자리가 1,2,3,4,6,7,8,9,0,2,3,4,5

끝 두자리 합이
3,6,9,12,6,9,12,15,8,2,5


딱 나누어지는 수는 2,4,6,8,0 으로 끝난다.
그렇다고 2,4,6,8,0으로 끝나는 수가 반드시 딱 나누어지는 것은 아님.
반례 22


3, 6, 9, 12, 6, 9, 12, 6, 9 ,3

그니까 내가 하고 싶은건,
반복되는 뒤 n자리만 확인하고 나머지를 찾아내는 것.

나머지는 12 미만이다.
나눠지는 수 - 배수 = 나머지

나눠지는 수 = 배수 + 나머지

배수는 나눠지는 수보다 작거나 같다.



일단 C보다 정답이 커질 수 없음.

2,147,483,647^2,147,483,647 => 이거 솔직히 못구함.
=> 뭔가 대체해서 판별해야한다는 건데.

거듭제곱 하더라도, C자리만 보면됨.

한번 거듭 제곱하는 것 까지는 버틸 수 있을 것 같은데.



24 * 24 / 32


10^11 / 12

큰수 쪽을 무시할 수 있을까?

C의 배수 + 나머지가 소인수 중의 하나를 만들어 낼 수 있으면,

C x n + X = A^B
X를 알아내야함.
n도 모름.

이분 탐색으로
X에 대해서 조건을 만족하는 나머지인지 확인해야함.

(A^B - X) / C = 정수면 성립.
X는 정해져 있음. A,B,C도 정해져있음.

A^B / C - X/C = 정수

	10^11 /12 - 4/12 = 정수


X는 C보다 무조건 작음.


10^11/12 소수점 부분만 구하기.

10/12 x 10^10

구한 소수점 부분과 X/C를 뺐을 때 0이 나와야함.

0.33 - 0.33 = 0 


12 x n + 4 = 10^11

부동 소수점 오류 어떻게 할 것인가. => 일단 소수점 자리를 최대로 반올림한 다음, 마지막에 소수점 둘째 자리에서 올림.

--
와 근데 21억이라는 숫자를 과소 평가함....
진짜 너무 크네...

dp 써서 풀이

--
근데 또 정확도가 안맞다. 21억이다보니.
마지막에 올림을 적용하는 소수점 자리를 하나씩 낮춰보면서 테스트 
하나의 정답으로 수렴하는 소수점 자리를 찾아봄. =>  10의 11승
