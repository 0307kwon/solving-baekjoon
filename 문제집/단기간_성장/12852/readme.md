## 문제 소개

[1로 만들기 2](https://www.acmicpc.net/problem/12852)

## 풀이

dfs로 푸는 문제가 아니라 dp로 푸는 문제였습니다.

일관된 규칙이 보이지 않으면 모든 경우를 돌아보는 brute force 방법을 생각하고,

최대 값이 백만 정도로, 그리 크지 않은 것을 인지하고 dp 방법을 떠올려야했는데 dfs에 갇혀 떠올리지 못했습니다.

풀이 방법은 길이가 백만인 dp 배열을 하나 만들고,

작은 배열 idx부터 계산을 시작합니다.

현재 idx 기준으로 이전의 idx의 값을 활용해서 현재 idx의 값을 계산합니다.

특정 값 n에 도달하는 최소의 연산 경로를 찾는 것이므로,

이전 idx 값으로 계산할 수 있는 현재의 값 중 가장 작은 값을 찾는 방법으로 연산을 반복합니다.

O(n)으로 충분히 가능하므로 시간 복잡도는 문제없습니다.

경로를 되짚어가기 위한 prevValue 라는 배열도 만들어, 특정 idx의 이전 idx를 저장하고 마지막에는 idx n 부터 이전으로 되짚어가며 경로를 출력합니다.


## 처음 풀이

푸는 데에는 실패했습니다. 다음 주에 다시 도전하여 맞춰보겠습니다.

제가 접근한 방식은 dfs 방식이었습니다.

다만 입력으로 들어오는 값이 10^6이기 때문에, 시간 복잡도가 고민이었습니다.

3을 나누었을 때 나머지는 0,1,2

2를 나누었을 때 나머지는 0,1

즉, 나누어떨어지는 나머지 0을 제외하면 나머지가 1이나 2가 나옵니다.

제가 생각한 최악의 경우는 계속 나머지가 2라서, 1로 2번 빼고 3으로 나누는 경우를 최악의 경우라고 생각하였습니다. (1을 계속 빼는 경우는 존재할 수 없음.)

최악의 경우로 생각해보면, 3번의 연산마다 값이 1/3으로 감소하므로

$3*(log 10^6 / log 3)$ 로 볼 수 있습니다. (=**37.7262589372 ~= 약 38)**

그런데 저는 dfs로 1,2,3번 연산에 대해 모두 순회하므로

연산의 경우의 수 3을 밑으로 순회 횟수를 계산하면

3^38번(~=**1.3508517e+18) 입니다. (여기서 다른 방법을 찾아봤어야하는데…)**

저는 그래서 3이라는 밑과, 38이라는 지수를 최대한 줄이려고 노력을 해봤지만

특정 케이스를 가지치기 하는 방법을 쓰다가 잘못 생각하여 오답이 나오기도 하고,

여전히 시간초과가 발생하기도 하였습니다.

시간을 꽤 들였음에도 풀지못하여 잘못된 접근인가 싶어 다음주에 다시 도전해보겠습니다. 😢
