## 문제 소개

[격자상의 경로](https://www.acmicpc.net/problem/10164)

큰 작업을 잘게 쪼개어 연산하는 방식을 생각해보았을 때,

end point에서 이전으로 돌아가면서 연산하는 방법을 생각해볼 수 있습니다.

![Untitled](https://upload.acmicpc.net/8299a142-dd28-48bc-a698-64b8789e4733/-/preview/)

예를 들어, 15 까지 갈 수 있는 경로를 14와 10까지 갈 수 있는 경로의 합으로 구할 수 있습니다.

따라서 재귀를 역방향으로 최초 포인트에 도달할 때까지 연산하면 정답이 나옵니다.

시간 제한을 고려하기 위해 연산량을 체크해보면,

N x M 은 최대 15 x 15 = 225개의 격자가 가능하고,

225개의 격자 연산에 사용되는 연산은 N x M - 1, 즉 224개의 연산이 필요합니다.

따라서 시간은 충분하다 생각했습니다.

추가적으로 K가 0이 아니면, 특정 포인트를 경유하는 경로의 수를 구해야하므로

numberOfPath(1, K) + numberOfPath(K, N*M)을 구하면 정답이 나옵니다.
